package controllers

import (
	"config-manager/application"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"

	"github.com/labstack/echo/v4"

	"github.com/redhatinsights/platform-go-middlewares/identity"
)

// ConfigManagerController implements ServerInterface
type ConfigManagerController struct {
	ConfigManagerService *application.ConfigManagerService
	Server               *echo.Echo
}

// Routes sets up middlewares and registers handlers for each route
func (cmc *ConfigManagerController) Routes() {
	cmc.Server.Use(echo.WrapMiddleware(identity.EnforceIdentity))
	// TODO: This is a weird way to register the routes. Should probably
	// remove Server from this controller and instead create an api "main.go"
	RegisterHandlers(cmc.Server, cmc)
}

// Start starts an http server with addr
func (cmc *ConfigManagerController) Start(addr string) {
	cmc.Server.Start(addr)
}

// TODO: Revisit this - should defaults be set by autogenerated server code?
func translateRunsParams(params GetRunsParams) map[string]interface{} {
	p := map[string]interface{}{
		"filter":  "",
		"sort_by": "created_at",
		"limit":   50,
		"offset":  0,
	}

	if params.Filter != nil {
		p["filter"] = string(*params.Filter)
	}
	if params.SortBy != nil {
		p["sort_by"] = string(*params.SortBy)
	}
	if params.Limit != nil {
		p["limit"] = int(*params.Limit)
	}
	if params.Offset != nil {
		p["offset"] = int(*params.Offset)
	}

	return p
}

// TODO: Again I don't like this.. Come up with a better solution for validating params (middleware?)
func translateChangesParams(params GetChangesParams) map[string]interface{} {
	p := map[string]interface{}{
		"limit":  50,
		"offset": 0,
	}

	if params.Limit != nil {
		p["limit"] = int(*params.Limit)
	}
	if params.Offset != nil {
		p["offset"] = int(*params.Offset)
	}

	return p
}

// GetStates gets the configuration state for requesting account
// (GET /states)
func (cmc *ConfigManagerController) GetStates(ctx echo.Context) error {
	id := identity.Get(ctx.Request().Context())
	fmt.Println("Getting state for account: ", id.Identity.AccountNumber)

	acc, err := cmc.ConfigManagerService.GetAccountState(id.Identity.AccountNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	return ctx.JSON(http.StatusOK, acc)
}

// PostStates updates the configuration state for requesting account
// (POST /states)
func (cmc *ConfigManagerController) PostStates(ctx echo.Context) error {
	id := identity.Get(ctx.Request().Context())
	fmt.Println("Updating state for account: ", id.Identity.AccountNumber)

	payload := &AccountStateInput{}
	bytes, err := ioutil.ReadAll(ctx.Request().Body)
	if err != nil {
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	err = json.Unmarshal(bytes, payload)
	if err != nil {
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	acc, err := cmc.ConfigManagerService.UpdateAccountState(id.Identity.AccountNumber, "demo-user", payload.State.AdditionalProperties)
	if err != nil {
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	//TODO get number of connected clients (inventory repository?) and build response object that contains
	//both acc and number of clients for 'pre flight check' purposes

	return ctx.JSON(http.StatusOK, acc)
}

// GetChanges gets all state changes for requesting account
// (GET /changes)
func (cmc *ConfigManagerController) GetChanges(ctx echo.Context, params GetChangesParams) error {
	id := identity.Get(ctx.Request().Context())
	fmt.Println("Getting state changes for account: ", id.Identity.AccountNumber)

	p := translateChangesParams(params)

	// Add filter and sort-by
	states, err := cmc.ConfigManagerService.GetStateChanges(
		id.Identity.AccountNumber,
		p["limit"].(int),
		p["offset"].(int),
	)
	if err != nil {
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	return ctx.JSON(http.StatusOK, states)
}

// GetChangesId get single state change for requesting account
// (GET /changes/{id})
func (cmc *ConfigManagerController) GetChangesId(ctx echo.Context, stateID StateIDParam) error {
	id := identity.Get(ctx.Request().Context())
	fmt.Printf("Getting state change for account: %s, with id: %s\n", id.Identity.AccountNumber, string(stateID))

	state, err := cmc.ConfigManagerService.GetSingleStateChange(string(stateID))
	if err != nil {
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	return ctx.JSON(http.StatusOK, state)
}

// GetRuns gets a list of runs for requesting account
// (GET /runs)
func (cmc *ConfigManagerController) GetRuns(ctx echo.Context, params GetRunsParams) error {
	id := identity.Get(ctx.Request().Context())
	fmt.Println("Getting runs for account: ", id.Identity.AccountNumber)

	p := translateRunsParams(params)

	runs, err := cmc.ConfigManagerService.GetRuns(
		id.Identity.AccountNumber,
		p["filter"].(string),
		p["sort_by"].(string),
		p["limit"].(int),
		p["offset"].(int),
	)
	if err != nil {
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	return ctx.JSON(http.StatusOK, runs)
}

// GetRunsId gets a single run by run_id
// (GET /runs/{id})
func (cmc *ConfigManagerController) GetRunsId(ctx echo.Context, runID RunIDParam) error {
	id := identity.Get(ctx.Request().Context())
	fmt.Printf("Getting run for account: %s with run_id: %s\n", id.Identity.AccountNumber, string(runID))

	run, err := cmc.ConfigManagerService.GetSingleRun(string(runID))
	if err != nil {
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	return ctx.JSON(http.StatusOK, run)
}

// PostRuns generates new runs by applying a state change
// (POST /runs)
func (cmc *ConfigManagerController) PostRuns(ctx echo.Context) error {
	var id identity.XRHID
	id = identity.Get(ctx.Request().Context())
	fmt.Println("Applying state for account: ", id.Identity.AccountNumber)

	clients, err := cmc.ConfigManagerService.GetClients(id.Identity.AccountNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	// TODO: Update ApplyState to return proper response data (dispatcher response code + id per client)

	run, err := cmc.ConfigManagerService.ApplyState(id.Identity.AccountNumber, "demo-user", clients.Clients)
	if err != nil {
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	return ctx.JSON(http.StatusOK, run)
}
